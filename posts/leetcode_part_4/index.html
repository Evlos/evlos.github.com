<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Evlos.blog() | Leetcode Part 4</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=generator content="Hugo 0.76.5"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-66839894-6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-66839894-6');</script></head><body><header><div><nav role=navigation><div><a href=/>Evlos.blog()</a><div><ul><li><a href=/ title="Home page">Home</a></li></ul></div></div></nav></div></header><main role=main><article><header><p>POSTS</p><h1>Leetcode Part 4</h1><time datetime=2019-12-25T18:13:42+08:00>December 25, 2019</time></header><section><blockquote><p>The Operators:</p><p>x &#171; y</p><p>Returns x with the bits shifted to the left by y places (and new bits on the right-hand-side are zeros). This is the same as multiplying x by 2**y.</p><p>x &#187; y</p><p>Returns x with the bits shifted to the right by y places. This is the same as //&lsquo;ing x by 2**y.</p><p>x & y</p><p>Does a &ldquo;bitwise and&rdquo;. Each bit of the output is 1 if the corresponding bit of x AND of y is 1, otherwise it&rsquo;s 0.</p><p>x | y</p><p>Does a &ldquo;bitwise or&rdquo;. Each bit of the output is 0 if the corresponding bit of x AND of y is 0, otherwise it&rsquo;s 1.</p><p>~ x</p><p>Returns the complement of x - the number you get by switching each 1 for a 0 and each 0 for a 1. This is the same as -x - 1.</p><p>x ^ y</p><p>Does a &ldquo;bitwise exclusive or&rdquo;. Each bit of the output is the same as the corresponding bit in x if that bit in y is 0, and it&rsquo;s the complement of the bit in x if that bit in y is 1.</p><p>Just remember about that infinite series of 1 bits in a negative number, and these should all make sense.</p></blockquote><h2 id=bitwise-operators>Bitwise operators</h2><h3 id=191-number-of-1-bits>191. Number of 1 Bits</h3><p><a href=https://leetcode.com/problems/number-of-1-bits/description/>https://leetcode.com/problems/number-of-1-bits/description/</a></p><pre><code>class Solution:
  def hammingWeight(self, n: int) -&gt; int:
    count, mask = 0, 0b1
    for _ in range(32):
      if n &amp; mask != 0:
        count += 1
      mask &lt;&lt;= 1
    return count

if __name__ == '__main__':
  assert Solution().hammingWeight(0b00000000000000000000000000001011) == 3
</code></pre><p><strong>32 ms 12.8 MB</strong></p><h3 id=136-single-number>136. Single Number</h3><p><a href=https://leetcode.com/problems/single-number/description/>https://leetcode.com/problems/single-number/description/</a></p><pre><code>class Solution:
  def singleNumber(self, nums):
    x = 0
    for item in nums:
      x = x ^ item
    return x

if __name__ == '__main__':
  assert Solution().singleNumber([4, 1, 2, 1, 2]) == 4
</code></pre><p><strong>88 ms 15 MB</strong></p><h4 id=alternative-solutions>Alternative solutions:</h4><pre><code>class Solution:
  def singleNumber(self, nums: List[int]) -&gt; int:
    import functools
    return functools.reduce(lambda x, y: x ^ y, nums)
</code></pre><h3 id=461-hamming-distance>461. Hamming Distance</h3><p><a href=https://leetcode.com/problems/hamming-distance/>https://leetcode.com/problems/hamming-distance/</a></p><pre><code>class Solution:
  def hammingDistance(self, x, y):
    raw, count, mask = x ^ y, 0, 1
    for _ in range(32):
      if raw &amp; mask:
        count += 1
      mask &lt;&lt;= 1
    return count

if __name__ == '__main__':
  assert Solution().hammingDistance(1, 4) == 2
</code></pre><p><strong>24 ms 12.8 MB</strong></p><ul></ul></section><aside></aside></article><p class=back-to-posts><a href=/>[back]</a></p></main><footer role=contentinfo><br>&copy; 2009-2020 <a href=/>Evlos.blog()</a><p>Theme: CSS-every-working-day-but-not-today made by Evlos.</p><div></div></footer></body></html>